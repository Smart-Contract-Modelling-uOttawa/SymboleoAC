const {LegalPosition, Asset, Event, Role, Obligation, Power, SymboleoContract} = require('symboleo-js-core');
const { Resource } = require('./Resource.js');
const { Rule } = require('./Rule.js');
const { Operation } = require('./Operation.js');


class ACPolicy extends Resource{
    constructor(allController) {
        super(allController);
        this._rules = [];
        this._constraints = [];
    }


/* Code from template association_GetMany */
getRule(index) {
    let aRule = this._rules[index];
    return aRule;
}


getRules() {
    let newRules = Object.freeze(this._rules);
    return newRules;
}

numberOfRules() {
    let number = this._rules.length;
    return number;
}

hasRules() {
    let has = this._rules.length > 0;
    return has;
}

indexOfRule(aRule) {
    let index = this.rules.indexOf(aRule); 
    return index;

}

//Utility function 
//not generated by Umple, we use it to search for a rule
findRule(aRule){
    return this._rules.find(obj => obj.decision === aRule.decision && obj.permission === aRule.permission && obj.accessedResource === aRule.accessedResource && obj.accessedRole === aRule.accessedRole);  
}

//Utility function
//this will create a rule, and search if it exesits in the list of rules
//it should check if he has a rule, if not, it will check if he is the controller, performer, rightHolder, liable
hasPermesstion(aDecision,aAction, aAccessedResource, aAccessedRole, aByRole){
let aRule = new Rule(aDecision, aAction, aAccessedResource, aAccessedRole,aByRole, this)
if(this.findRule(aRule)){
    return true
  }else{

    if(aRule.accessedResource.findController(aRule.accessedRole)){
       if(!(aRule.accessedResource instanceof Event) && !(aRule.accessedResource instanceof Asset) && !(aRule.accessedResource instanceof Role) ){//aRule.permission === 'Read' &&
        return true 
       }else
       {
        if(aRule.permission === 'read')
        return true 
       }
    }
    if(aRule.accessedResource instanceof Asset){
        if(aRule.accessedResource._owners._value === aRule.accessedRole){
        return true
        }
    }
    if((aRule.accessedResource instanceof LegalPosition) || (aRule.accessedResource instanceof Event) || (aRule.accessedResource instanceof Operation)){ //|| (aRule.accessedResource instanceof Operation) 
       if(aRule.accessedResource._performer.includes(aRule.accessedRole))
       {
        return true
    }
    if(aRule.accessedResource instanceof Obligation){
        if(aRule.accessedResource._rightHolder.includes(aRule.accessedRole)){
            return true
        }
        if(aRule.accessedResource._liable.includes(aRule.accessedRole)){
            return true
        }
    }
    if(aRule.accessedResource instanceof Power){
        if(aRule.accessedResource._liable.includes(aRule.accessedRole)){
            return true
        }
        if(aRule.accessedResource._rightHolder.includes(aRule.accessedRole)){
            return true
        }
    }
    }// end if for instance of legal posiiton, event, operation
    if(aRule.accessedResource instanceof Role){
        if(aRule.accessedResource === aRule.accessedRole ){
           return true
        }
    }// end if for Role
    return false
  }
}

hasPermesstionOnLegalPosition(aDecision,aAction, aAccessedResource, aAccessedRole, aByRole, aContract){
    let aRule = new Rule(aDecision, aAction, aAccessedResource, aAccessedRole,aByRole, this)
    

    for (const obligationKey of Object.keys(aContract.obligations)) {
        aContract.obligations[obligationKey].consequent
        if(aContract.obligations[obligationKey].consequent.consequentOf.find(obj => obj === aAccessedResource) &&  aContract.obligations[obligationKey]._performer.find(obj => obj === aAccessedRole)){
            return this.isValid(aRule)
        }
      }

      for (const powerKey of Object.keys(aContract.powers)) {
        if(aContract.powers[powerKey].consequent.consequentOf.find(obj => obj === aAccessedResource)  &&  aContract.powers[powerKey]._performer.includes(aRule.accessedRole)){
            return this.isValid(aRule)
        }
      }
   return false
}
    
/* Code from template association_MinimumNumberOfMethod */
static minimumNumberOfRules() {
    return 0;
}

/* Code from template association_AddManyToOne */
addRulee(aDecision, aPermission, aAccessedResource, aAccessedRole, aByRole) { 
    let aRule = new Rule(aDecision, aPermission, aAccessedResource, aAccessedRole, aByRole, this);
    if(aRule != null && ! (typeof aRule === 'undefined')){
       if(this.findController(aByRole)){
        this.addPolicy(aRule)
    
       }else{
        this.addRule(aRule) 
       }
    }
    return aRule
}

addRule(aRule) {
    let wasAdded = false;

    //to check if the rule exist, or has pre-authrized permesstion. 
    if (this.hasPermesstion(aRule.decision,aRule.permission, aRule.accessedResource, aRule.accessedRole, aRule.byRole)) { //this._rules.includes(aRule) ||
        return false;
    }

    if(this.isValid(aRule)){
        if(this.updateRule(aRule)){
            this._rules.push(aRule);
        }
        
    }
    
    wasAdded = true;
    return wasAdded;
}

//AC- To be completed 
removeRule(aRule) {
    let wasRemoved = false;
    if(this.findRule(aRule)){
        if(aRule.accessedResource.getController().includes())
        this._rules.pop(aRule)
        wasRemoved = true;
    }

      return wasRemoved;
   
}

/* Code from template association_AddIndexControlFunctions */

addRuleAt(aRule, index) {
    let wasAdded = false;
    
    if (this.addRule(aRule)) {
        if (index < 0) { index = 0; }
        if (index > this.numberOfRules()) { index = this.numberOfRules(); }
        
        this._rules.splice(index, 0, aRule);
        wasAdded = true;
    }
    
    return wasAdded;
}

addOrMoveRuleAt(aRule, index) {
    let wasAdded = false;
    
    if (this._rules.includes(aRule)) {
        if (index < 0) { index = 0; }
        if (index > this.numberOfRules()) { index = this.numberOfRules(); }
        
        this._rules.splice(this._rules.indexOf(aRule), 1);
        this._rules.splice(index, 0, aRule);
        wasAdded = true;
    } else {
        wasAdded = this.addRuleAt(aRule, index);
    }
    
    return wasAdded;
}

//Utility function 
findPolicy(aRule){
    return this._constraints.find(obj => obj.decision === aRule.decision && obj.permission === aRule.permission && obj.accessedResource === aRule.accessedResource && obj.accessedRole === aRule.accessedRole);  
}

//Utility function 
//AC-check if the rules does not contain rules that conflict with the policy(constraines)
isValid(aRule){
let isValidVar = true
        this._constraints.forEach(constraint => {
            if(constraint.accessedResource === aRule.accessedResource && constraint.accessedRole === aRule.accessedRole)
            {
                switch (aRule.decision) {
                    case 'grant':
                        switch (aRule.permission) {
                            case 'read':
                                    if((
                                        constraint.decision === 'revoke' && 
                                            (constraint.permission === 'read' || constraint.permission === 'all')) ){
                                        isValidVar = false
                                        return false
                                    }
                                break;
                            case 'write':
                                if((constraint.decision === 'revoke' && 
                                    (constraint.permission === 'write' || constraint.permission === 'all'))||(constraint.decision === 'grant' && constraint.permission === 'read')){
                                        isValidVar = false
                                        return false
                                    }
                                break;
                            case 'all':
                                if((constraint.decision === 'revoke')){
                                    isValidVar = false
                                    return false
                                }
                                break;
                            case 'transfer':
                                if(constraint.decision === 'revoke' && 
                                    (constraint.permission === 'transfer' || constraint.permission === 'all')){
                                    isValidVar = false
                                    return false
                                    }
                                break;
                        }
                        break;
                    case 'revoke':
                        switch (aRule.permission.toLowerCase()) {
                            case 'read':
                                 if(constraint.decision === 'grant' && 
                                    (constraint.permission === 'read' || constraint.permission === 'all' || constraint.permission === 'write' )){
                                        isValidVar = false
                                        return false
                                    }
                                break
                            case 'write':
                                if(constraint.decision === 'grant' && 
                                    (constraint.permission === 'write' || constraint.permission === 'all')){
                                        isValidVar = false
                                        return false
                                    }
                                break;
                            case 'all':
                                if(constraint.decision === 'grant'){
                                    isValidVar = false
                                    return false
                                }
                                break;
                            case 'transfer':
                                 if(constraint.decision === 'grant' && 
                                    (constraint.permission === 'transfer' || constraint.permission === 'all')){
                                        isValidVar = false
                                        return false
                                    }
                                break;
                        }
                        break;
                }// end switch

            }//end if

        });//end forEach
        return isValidVar;
    }


//AC
//utility function 
updatePolicy(aRule) {
    let canAdd = true;
    let rulesToRemove = [];
    let rulesToAdd = [];
    this._constraints.forEach(constraint => {
        if (constraint.accessedResource === aRule.accessedResource && constraint.accessedRole === aRule.accessedRole) {//constraint.accessedResource === aRule.accessedResource && constraint.accessedRole === aRule.accessedRole
            switch (aRule.decision) {
                case 'grant':
                    switch (aRule.permission) {
                        case 'read':
                            switch (constraint.decision) {
                                case 'grant':
                                    if (constraint.permission === 'write' || constraint.permission === 'all') return false;
                                    break;
                                case 'revoke':
                                    if (constraint.permission === 'read') {
                                        constraint.decision = 'grant';
                                        canAdd =  false;
                                        
                                    }
                                    if (constraint.permission === 'all') {
                                        constraint.permission = 'write';
                                        let remainedRule = new Rule('revoke', 'transfer', constraint.accessedResource, constraint.accessedRole, constraint.byRole, this);
                                        rulesToAdd.push(remainedRule)
                                    
                                    }
                                    break;
                            }
                            break;
                        case 'write':
                            switch (constraint.decision) {
                                case 'grant':
                                    if (constraint.permission === 'all') return false;
                                    if (constraint.permission === 'read') {
                                        constraint.permission = 'write';
                                        canAdd =  false;
                                         
                                    }
                                    break;
                                case 'revoke':
                                    if (constraint.permission === 'write') {
                                        constraint.decision = 'grant';
                                        canAdd =  false;
                                        
                                    }
                                    if(constraint.permission === 'read'){
                                        constraint.decision = 'grant'
                                        constraint.permission = 'write'
                                        canAdd =  false
                                        
                                    }
                                    if (constraint.permission === 'all'){
                                        constraint.permission = 'transfer'
                                     
                                    }
                                    break;
                            }
                            break;
                        case 'all':
                            switch (constraint.decision) {
                                case 'grant':
                                    if(constraint.permission === 'read' || constraint.permission === 'write' || constraint.permission === 'transfer'){
                                        rulesToRemove.push(constraint)
                                    
                                    }
                                    break;
                                case 'revoke':
                                    if(constraint.permission === 'all'){
                                    constraint.decision = 'grant';
                                    canAdd =  false;
                                    
                                    }
                                    if(constraint.permission === 'read' || constraint.permission === 'write' || constraint.permission === 'transfer'){
                                        rulesToRemove.push(constraint)
                                       
                                    }
                                    
                            }
                            break;
                        case 'transfer':
                            switch(constraint.decision)
                            {
                                case 'grant':
                                    if(constraint.permission === 'all'){
                                        canAdd =  false
                                        
                                    }
                                case 'revoke':
                                    if(constraint.permission === 'all'){
                                        constraint.permission = 'write'
                                        let remainedRule = new Rule('revoke', 'read', constraint.accessedResource, constraint.accessedRole,constraint.byRole, this);
                                        rulesToAdd.push(remainedRule)
                                     
                                    }
                            }
                            break
                    }
                    break;
                case 'revoke':
                    switch (aRule.permission) {
                        case 'read':
                            switch (constraint.decision) {
                                case 'grant':
                                    if (constraint.permission === 'read' ) {
                                        constraint.decision = 'revoke';
                                        canAdd =  false;
                                        
                                    }
                                    if(constraint.permission === 'all'){
                                        constraint.decision = 'grant'
                                        constraint.permission = 'transfer'
                                    
                                    }
                                    if(constraint.permission === 'write'){
                                        constraint.decision = 'revoke'
                                        constraint.permission = 'read'
                                        canAdd =  false
                                        
                                    }
                                    break;
                                case 'revoke':
                                    if(constraint.permission === 'write' || constraint.permission === 'all'){
                                        canAdd =  false
                                        
                                    }
                                    break; 
                            }
                            break;
                        case 'write':
                            switch (constraint.decision) {
                                case 'grant':
                                    if (constraint.permission === 'write') {
                                        constraint.decision = 'revoke';
                                        canAdd =  false;
                                        
                                    }
                                    if(constraint.permission === 'read'){
                                        constraint.permission = 'write'
                                        constraint.decision = 'revoke';
                                        canAdd =  false
                                        
                                    }
                                    if(constraint.permission === 'all'){
                                        constraint.permission = 'transfer'
                                     
                                    }
                                    break;
                                case 'revoke':
                                    if(constraint.permission === 'read'){
                                        constraint.permission = 'write'
                                        canAdd =  false
                                        
                                    }
                                    if(constraint.permission === 'all'){
                                        canAdd =  false
                                        
                                    }
                                    break; 
                            }
                            break;
                        case 'all':
                            switch (constraint.decision) {
                                case 'grant':
                                    if(constraint.permission === 'read' || constraint.permission === 'write' || constraint.permission === 'transfer'){
                                        rulesToRemove.push(constraint)
                                      
                                    }
                                
                                case 'revoke':
                                    if(constraint.permission === 'read' || constraint.permission === 'write' || constraint.permission === 'transfer'){
                                        rulesToRemove.push(constraint)
                                     
                                    }
                                    break; 
                            }
                            break;
                        case 'transfer':
                            switch(constraint.decision){
                                case 'grant':
                                    if(constraint.permission === 'transfer'){
                                        constraint.decision = 'revoke'
                                        canAdd =  false
                                        
                                    }
                                    if(constraint.permission === 'all'){
                                        constraint.permission === 'write'
                                       
                                    }
                                case 'revoke':
                                    if(constraint.permission === 'all'){
                                        canAdd =  false
                                        
                                    }
                            }
                        break
                    }
                    break;
            }
        }
    });
    

    // Remove rules marked for deletion
    this._constraints = this._constraints.filter(
        element => !rulesToRemove.includes(element)
    );

    // Add new rules
    rulesToAdd.forEach(rule => this._constraints.push(rule));

    return canAdd;
}

//utlity function 
//modify permission according to the new rule (by controller of rules)
updateRule(aRule) {
    let canAdd = true;
    let rulesToRemove = [];
    let rulesToAdd = [];
    this._rules.forEach(constraint => {
        if (constraint.accessedResource === aRule.accessedResource && constraint.accessedRole === aRule.accessedRole) {//constraint.accessedResource === aRule.accessedResource && constraint.accessedRole === aRule.accessedRole
            switch (aRule.decision) {
                case 'grant':
                    switch (aRule.permission) {
                        case 'read':
                            switch (constraint.decision) {
                                case 'grant':
                                    if (constraint.permission === 'write' || constraint.permission === 'all') return false;
                                    break;
                                case 'revoke':
                                    if (constraint.permission === 'read') {
                                        //give him back the read permission
                                        constraint.decision = 'grant';
                                        canAdd =  false;
                                        
                                    }
                                    if (constraint.permission === 'all') {
                                        constraint.permission = 'write';
                                        let remainedRule = new Rule('revoke', 'transfer', constraint.accessedResource, constraint.accessedRole, constraint.byRole, this);
                                        rulesToAdd.push(remainedRule)
                                
                                    }
                                    break;
                            }
                            break;
                        case 'write':
                            switch (constraint.decision) {
                                case 'grant':
                                    if (constraint.permission === 'all') return false;
                                    if (constraint.permission === 'read') {
                                        constraint.permission = 'write';
                                        canAdd =  false;
                                         
                                    }
                                    break;
                                case 'revoke':
                                    if (constraint.permission === 'write') {
                                        constraint.decision = 'grant';
                                        canAdd =  false;
                                        
                                    }
                                    if(constraint.permission === 'read'){
                                        constraint.decision = 'grant'
                                        constraint.permission = 'write'
                                        canAdd =  false
                                        
                                    }
                                    if (constraint.permission === 'all'){
                                        constraint.permission = 'transfer'
                                    
                                    }
                                    break;
                            }
                            break;
                        case 'all':
                            switch (constraint.decision) {
                                case 'grant':
                                    if(constraint.permission === 'read' || constraint.permission === 'write' || constraint.permission === 'transfer'){
                                        //push to be deleted
                                        rulesToRemove.push(constraint)
                                        
                                    }
                                    break;
                                case 'revoke':
                                    if(constraint.permission === 'all'){
                                    constraint.decision = 'grant';
                                    canAdd =  false;
                                    
                                    }
                                    if(constraint.permission === 'read' || constraint.permission === 'write' || constraint.permission === 'transfer'){
                                        //push to be deleted
                                        rulesToRemove.push(constraint)
                                      
                                    }
                                    
                            }
                            break;
                        case 'transfer':
                            switch(constraint.decision)
                            {
                                case 'grant':
                                    if(constraint.permission === 'all'){
                                        canAdd =  false
                                        
                                    }
                                case 'revoke':
                                    if(constraint.permission === 'all'){
                                        constraint.permission = 'write'
                                        let remainedRule = new Rule('revoke', 'read', constraint.accessedResource, constraint.accessedRole,constraint.byRole, this);
                                        rulesToAdd.push(remainedRule)
                                     
                                    }
                            }
                            break
                    }
                    break;
                case 'revoke':
                    switch (aRule.permission) {
                        case 'read':
                            switch (constraint.decision) {
                                case 'grant':
                                    if (constraint.permission === 'read' ) {
                                        constraint.decision = 'revoke';
                                        canAdd =  false;
                                        
                                    }else
                                    if(constraint.permission === 'all'){
                                        constraint.decision = 'grant'
                                        constraint.permission = 'transfer'
                                      
                                    }else
                                    if(constraint.permission === 'write'){
                                        constraint.decision = 'revoke'
                                        constraint.permission = 'read'
                                        //add revoke read
                                        canAdd =  false
                                        
                                    }
                                    break;
                                case 'revoke':
                                    if(constraint.permission === 'write' || constraint.permission === 'all'){
                                        canAdd =  false
                                        
                                    }
                                    break; // No action needed if already revoked
                            }
                            break;
                        case 'write':
                            switch (constraint.decision) {
                                case 'grant':
                                    if (constraint.permission === 'write') {
                                        constraint.decision = 'revoke';
                                        canAdd =  false;
                                        
                                    }
                                    if(constraint.permission === 'read'){
                                        constraint.permission = 'write'
                                        constraint.decision = 'revoke';
                                        canAdd =  false
                                        
                                    }
                                    if(constraint.permission === 'all'){
                                        constraint.permission = 'transfer'
                                       
                                    }
                                    break;
                                case 'revoke':
                                    if(constraint.permission === 'read'){
                                        constraint.permission = 'write'
                                        canAdd =  false
                                        
                                    }
                                    if(constraint.permission === 'all'){
                                        canAdd =  false
                                        
                                    }
                                    break; 
                            }
                            break;
                        case 'all':
                            switch (constraint.decision) {
                                case 'grant':
                                    if(constraint.permission === 'read' || constraint.permission === 'write' || constraint.permission === 'transfer'){
                                        //push to be deleted
                                        rulesToRemove.push(constraint)
                                      
                                    }
                                
                                case 'revoke':
                                    if(constraint.permission === 'read' || constraint.permission === 'write' || constraint.permission === 'transfer'){
                                        //push to be deleted
                                        rulesToRemove.push(constraint)
                                       
                                    }
                                    break; 
                            }
                            break;
                        case 'transfer':
                            switch(constraint.decision){
                                case 'grant':
                                    if(constraint.permission === 'transfer'){
                                        constraint.decision = 'revoke'
                                        canAdd =  false
                                        
                                    }
                                    if(constraint.permission === 'all'){
                                        constraint.permission === 'write'
                                     
                                    }
                                case 'revoke':
                                    if(constraint.permission === 'all'){
                                        canAdd =  false
                                        
                                    }
                            }
                        break
                    }
                    break;
            }
        }
    });

    // Remove rules marked for deletion
    this._rules = this._rules.filter(
        element => !rulesToRemove.includes(element)
    );

    // Add new rules

    rulesToAdd.forEach(rule => this._rules.push(rule));

    return canAdd;
}


//Utility function 
//AC-Policies are enforced automatically after every authorization/deauthorization(addRule/deleteRule)
//Constraints
addPolicy(aRule){
    let wasAdded = false;

    //to check if the policy exist
    if (this.findPolicy(aRule) || this.hasPermesstion(aRule.decision,aRule.permission, aRule.accessedResource, aRule.accessedRole, aRule.byRole )) {  //this.hasPermesstion(aRule.decision,aRule.permission, aRule.accessedResource, aRule.accessedRole)
        return false;
    }

    // if not exist add it
    if(this.updatePolicy(aRule)){
        this._constraints.push(aRule);
    }
    
    wasAdded = true;
    return wasAdded;
}

deletePolicy(){

}


delete() {
    while (this._rules.length > 0) {
        let aRule = this._rules[this._rules.length - 1];
        aRule.delete();
        this._rules.pop();
    }
    
    super.delete();
}

}

module.exports.ACPolicy = ACPolicy;

    
   
